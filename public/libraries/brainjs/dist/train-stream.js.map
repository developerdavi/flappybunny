{"version":3,"sources":["../src/train-stream.js"],"names":["TrainStream","opts","objectMode","neuralNetwork","Error","hiddenSizes","dataFormatDetermined","inputKeys","outputKeys","i","iterations","errorThresh","log","console","logPeriod","callback","callbackPeriod","floodCallback","doneTrainingCallback","size","count","sum","on","finishStreamIteration","bind","write","chunk","enc","next","emit","uniques","slice","concat","Object","keys","input","output","firstDatum","data","_formatData","trainDatum","datum","err","_trainPattern","inputLookup","lookup","lookupFromArray","Array","isArray","outputLookup","sizes","inputSize","length","outputSize","push","Math","max","floor","forEach","unshift","_initialize","error","Writable","arr","Set"],"mappings":"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","file":"train-stream.js","sourcesContent":["import { Writable } from 'stream';\nimport lookup from './lookup';\n\n/**\n *\n * @param opts\n * @returns {TrainStream}\n * @constructor\n */\nexport default class TrainStream extends Writable {\n  constructor(opts) {\n    super({\n      objectMode: true\n    });\n\n    opts = opts || {};\n\n    // require the neuralNetwork\n    if (!opts.neuralNetwork) {\n      throw new Error('no neural network specified');\n    }\n\n    this.neuralNetwork = opts.neuralNetwork;\n    this.hiddenSizes = opts.neuralNetwork.hiddenSizes;\n    this.dataFormatDetermined = false;\n\n    this.inputKeys = [];\n    this.outputKeys = []; // keeps track of keys seen\n    this.i = 0; // keep track of the for loop i variable that we got rid of\n    this.iterations = opts.iterations || 20000;\n    this.errorThresh = opts.errorThresh || 0.005;\n    this.log = opts.log ? (typeof opts.log === 'function' ? opts.log : console.log) : false;\n    this.logPeriod = opts.logPeriod || 10;\n    this.callback = opts.callback;\n    this.callbackPeriod = opts.callbackPeriod || 10;\n    this.floodCallback = opts.floodCallback;\n    this.doneTrainingCallback = opts.doneTrainingCallback;\n\n    this.size = 0;\n    this.count = 0;\n\n    this.sum = 0;\n\n    this.on('finish', this.finishStreamIteration.bind(this));\n\n    return this;\n  }\n\n  endInputs() {\n    this.write(false);\n  }\n\n  /**\n   * _write expects data to be in the form of a datum. ie. {input: {a: 1 b: 0}, output: {z: 0}}\n   * @param chunk\n   * @param enc\n   * @param next\n   * @returns {*}\n   * @private\n   */\n  _write(chunk, enc, next) {\n    if (!chunk) {\n      // check for the end of one iteration of the stream\n      this.emit('finish');\n      return next();\n    }\n\n    if (!this.dataFormatDetermined) {\n      this.size++;\n      this.inputKeys = uniques(this.inputKeys.slice(0).concat(Object.keys(chunk.input)));\n      this.outputKeys = uniques(this.outputKeys.slice(0).concat(Object.keys(chunk.output)));\n      this.firstDatum = this.firstDatum || chunk;\n      return next();\n    }\n\n    this.count++;\n\n    let data = this.neuralNetwork._formatData(chunk);\n    this.trainDatum(data[0]);\n\n    // tell the Readable Stream that we are ready for more data\n    next();\n  }\n\n  /**\n   *\n   * @param datum\n   */\n  trainDatum(datum) {\n    let err = this.neuralNetwork._trainPattern(datum.input, datum.output, true);\n    this.sum += err;\n  }\n\n  /**\n   *\n   * @returns {*}\n   */\n  finishStreamIteration() {\n    if (this.dataFormatDetermined && this.size !== this.count) {\n      this.log('This iteration\\'s data length was different from the first.');\n    }\n\n    if (!this.dataFormatDetermined) {\n      // create the lookup\n      this.neuralNetwork.inputLookup = lookup.lookupFromArray(this.inputKeys);\n      if(!Array.isArray(this.firstDatum.output)){\n        this.neuralNetwork.outputLookup = lookup.lookupFromArray(this.outputKeys);\n      }\n\n      let data = this.neuralNetwork._formatData(this.firstDatum);\n      let sizes = [];\n      let inputSize = data[0].input.length;\n      let outputSize = data[0].output.length;\n      let hiddenSizes = this.neuralNetwork.hiddenSizes;\n      if (!hiddenSizes) {\n        sizes.push(Math.max(3, Math.floor(inputSize / 2)));\n      } else {\n        hiddenSizes.forEach(size => {\n          sizes.push(size);\n        });\n      }\n\n      sizes.unshift(inputSize);\n      sizes.push(outputSize);\n\n      this.dataFormatDetermined = true;\n      this.neuralNetwork.sizes = sizes;\n      this.neuralNetwork._initialize();\n\n      if (typeof this.floodCallback === 'function') {\n        this.floodCallback();\n      }\n      return;\n    }\n\n    let error = this.sum / this.size;\n\n    if (this.log && (this.i % this.logPeriod === 0)) {\n      this.log('iterations:', this.i, 'training error:', error);\n    }\n    if (this.callback && (this.i % this.callbackPeriod === 0)) {\n      this.callback({\n        error: error,\n        iterations: this.i\n      });\n    }\n\n    this.sum = 0;\n    this.count = 0;\n    // update the iterations\n    this.i++;\n\n    // do a check here to see if we need the stream again\n    if (this.i < this.iterations && error > this.errorThresh) {\n      if (typeof this.floodCallback === 'function') {\n        return this.floodCallback();\n      }\n    } else {\n      // done training\n      if (typeof this.doneTrainingCallback === 'function') {\n        return this.doneTrainingCallback({\n          error: error,\n          iterations: this.i\n        });\n      }\n    }\n  }\n}\n\n/**\n *\n * https://gist.github.com/telekosmos/3b62a31a5c43f40849bb\n * @param arr\n * @returns {Array}\n */\nfunction uniques(arr) {\n  // Sets cannot contain duplicate elements, which is what we want\n  return [...new Set(arr)];\n}\n"]}